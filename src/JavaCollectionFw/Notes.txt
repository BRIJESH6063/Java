### COLLECTION FRAMEWORK ---

the hierarchy of the Collections Framework.
It consists of four core interfaces such as Collection, List, Set, Queue, and various classes
which get implemented through them.


### COLLECTION INTERFACE --
The Collection Interface is the root or the foundation on which the Collections Framework is built. It is a general interface that has the declaration:

interface Collection<E>
Here, E is the type of object that the collection will hold.

It provides basic operations like adding, removing, clearing the elements in a collection,
checking whether the collection is empty, etc.

-- List, Queue and Set are the components that extend the Collection Interface.

Collection Methods and their Description ----
1. boolean add(E obj)
It is used to add an object obj to the collection. Returns true if obj was added, else returns false
if the element obj was already a member and the collection does not allow duplicates.

2. boolean addAll(Collection<? extends E> c)
Adds all the elements of c to the collection.Returns true if the object was added, else returns false.


3.  void clear()	Removes all the elements from the collection.
4.  int size()	    Returns the number of elements present in the collection.
5.  Iterator        iterator()	Returns an iterator for the collection. It is an object that can be used to loop through collections.
6.  boolean         contains(Object obj)	Checks if the object is present in the collection and returns true if found. Else, it returns false.
7.  boolean         containsAll(Collection<?> c)	Returns true if the collection contains all the elements of c, else returns false.
8.  int hashCode()	It returns the hash code for the collection i.e., returns an integer or a 4 byte value which is generated by the hashing algorithm.

9.  boolean equals(Object obj)
    It returns true if the collection and obj are equal, else returns false.

10. boolean isEmpty()	Returns true if the collection is empty, else returns false.

11. boolean remove(Object obj)
    Removes one instance of obj from the collection. It returns true if the element was removed, else returns false.
12. boolean removeAll(Collection<?> c)
    Removes all elements of c from the collection. Returns true if the elements were removed, else returns false.
13. boolean retainAll(Collection<?> c)
    It retains only those elements which are in c and removes the other elements from the collection. It returns true if the elements were removed, else returns false.
14. default Spliterator spliterator()
    Returns a spliterator to the collection. A spliterator can be used to iterate over a collection and split it into **multiple sets.


#### ITERATOR INTERFACE ---
Iterator is an object that can be used to loop through collections.
As the name suggests, it is used to iterate over the elements. It is used to modify and iterate over the
elements in a collection.

There are 3 methods in the Iterator interface: ----
public Object next()-   It returns the next element in the collection. It throws the exception of
                        NoSuchElementException if there is no next element.
public void remove()-   It removes the current element from the collection.
public boolean hasNext()- It returns true if there are more elements in the collection. Else, returns false.

Iterable Interface: ----
The Iterable Interface allows the collection to be iterated over. The root interface for the entire collection
framework is termed the Iterable Interface. The collection interface extends the iterable interface,
hence the sub-classes of the collection interface also implement the iterable interface, i.e., it automatically
becomes a part of the iterable interface.

Syntax:

Iterator <E> iterator()

Returns an iterator of type E for the collection. It can be used to iterate over the elements of the collection.

LIST INTERFACE --
The list interface extends the collection interface. A list is used to store ordered collection of data and
it may contain duplicates. Ordered collection means the order in which the elements are being inserted and
they contain a specific value. The elements present, can be accessed or inserted by their position in the list
using zero-based indexing. The list interface is implemented by LinkedList, ArrayList, Vectors and Stack classes.
They are an important part of collections in Java.


There are three classes implemented by the list interface and they are given below.
Syntax --

List<Data-Type>linkedlist= new LinkedList<Data-Type>();
List<Data-Type>arraylist= new ArrayList<Data-Type>();
List<Data-Type>vector= new Vector<Data-Type>();


1. ArrayList
So, you must've figured it out from the name itself, that ArrayList is similar to Arrays.
They are also called dynamic arrays. That means it does not have a fixed size. Its size can be increased or decreased
if elements are added or removed.
-- It implements the List Interface.
-- It is similar to Vectors in C++.
-- Since the ArrayList cannot be used for primitive data types like int, char, etc. , we need to use a wrapper class.



### In order to initialize an ArrayList, there are 3 ways.

1. Using the add Keyword

    ArrayList<Data-Type> str = new ArrayList<Data-Type>();
        str.add(<content>);
        str.add(<content>);
        str.add(<content>);

    example --
    ArrayList<String> strArray = new ArrayList<String>() ;
    strArray.add("Hello" ) ;
    strArray.add("Mother") ;
    strArray.add("Father") ;
    System.out.println(strArray) ;


2. Using asList() AsList() method in Java is used to return a fixed-size list backed by the given array.

   ArrayList<Data-Type> obj =
       new ArrayList<Data-Type>(Arrays.asList(Obj A, Obj B, Obj C, ....));
   example --
   ArrayList<String> scale = new ArrayList<String>(Arrays.asList(
           "Hello", "Mother", "Fucker"
   )) ;
   System.out.println(scale) ;

3. Using list.of() Method It is used to return immutable lists containing the specified elements.

    List<Data-Type> obj = new ArrayList<>(
            List.of(Obj 1, Obj 1, Obj 1, ....));
    example --
    List<String> strArray = new ArrayList<>(
        List.of("Hello", "mother", "Father")
    ) ;
    System.out.println(strArray) ;


ArrayList<String> strArray = new ArrayList<>() ;
System.out.println("strArray.Size : "+ strArray.size()+" -- "+strArray) ;
strArray.add("Hello") ;
strArray.add("Mother") ;
strArray.add("Father") ;
strArray.add("Haha") ;
System.out.println("After data Addition to ArrayList");
System.out.println("strArray.Size : "+ strArray.size()+" -- "+strArray) ;
strArray.remove(0) ;
System.out.println("strArray.Size : "+ strArray.size()+" -- "+strArray) ;

output --
strArray.Size : 0 -- []
After data Addition to ArrayList
strArray.Size : 4 -- [Hello, Mother, Father, Haha]
strArray.Size : 3 -- [Mother, Father, Haha]


### 2. LinkedList
The LinkedList class extends the AbstractSequentialList and it also extends the List, Deque and Queue interface.
By this, we get a linked-list data structure.
Linked List is a linear data structure where the elements are called as nodes.

Here, each node has two fields- data and next.
Data stores the actual piece of information and next points to the next node.
'Next' field is actually the address of the next node.

Elements are not stored in a contiguous memory, so direct access to that element is not possible.
LinkedList uses Doubly Linked List to store its elements while ArrayList internally uses a dynamic array to store its elements.
LinkedList is faster in the manipulation of data as it is node-based which makes it unique.
LinkedList is non-synchronized means multiple threads at a time can access the code.
This means if one thread is working on LinkedList, other threads can also get a hold of it.
Multiple operations on LinkedList can be performed at a time. For example,
if addition is being performed by one thread, other operation can be performed by some other thread too.


1. Creating an empty Linked List

LinkedList list=new LinkedList();

2. Creating a Linked List from Collection

It will create a Linked List with all the elements of Collection C. We will use the LinkedList class and new keyword to create a constructor which contains the elements of collection.

LinkedList list=new LinkedList(C);



LinkedList<String> strList = new LinkedList<>() ;
System.out.println("strArray.Size : "+ strList.size()+" -- "+strList) ;
strList.add("Hello") ;
strList.addFirst("Mother") ;
strList.addLast("Father") ;
strList.add(1, "Haha") ;
System.out.println("After data Addition to ArrayList");
System.out.println("strArray.Size : "+ strList.size()+" -- "+strList) ;
strList.remove(0) ;
System.out.println("strArray.Size : "+ strList.size()+" -- "+strList) ;





#### 3. VECTOR --
-- Like ArrayList, Vectors in Java are used for dynamic arrays.
-- It extends the AbstractList and implements the List interface.
-- Vector is synchronised. Synchronised means only one thread at a time can access the code.
   This means if one thread is working on Vector, no other thread can get a hold of it. Only one operation on vector
   can be performed at a time. For example, if addition is being performed by one thread, other operation cannot be
   performed until the first one is over.
-- Before the introduction of the Collection Framework, Vectors were categorised as Legacy Classes(Classes
   which were a part of the earlier release of Java but now they are re-constructed).



Methods to create the constructor of Vectors
1. Using the default method
   In this method, the size is not specified so the default size of Vectors is 10.
   Vector<Data-type> v = new Vector<Data-Type>();

2. By specifying the desired size
   In this method, we specify the size.
   Vector<Data-type> v = new Vector<Data-Type>(int size);

3. Using size and increment attributes
   This method is used to create a vector whose initial capacity is declared by size and the increment is declared by incr. Here, the increment is the value that specifies the number of elements to allocate each time that vector gets resized upward.
   Vector<Data-type> v = new Vector<Data-Type>(int size,int incr);

4. Creating a Vector from Collection
   It is used to create a vector which contains all the elements of a collection.
   Vector<Data-type> v = new Vector<Data-Type>(Collection C);

Example --
Vector<String> strVector = new Vector<>() ;
System.out.println("strArray.Size : "+ strVector.size()+" -- "+strVector) ;
strVector.add("Hello") ;
strVector.add("Mother") ;
strVector.add("Father") ;
strVector.add("Haha") ;
System.out.println("After data Addition to ArrayList");
System.out.println("strArray.Size : "+ strVector.size()+" -- "+strVector) ;
strVector.remove(0) ;
System.out.println("strArray.Size : "+ strVector.size()+" -- "+strVector) ;

output --
strArray.Size : 0 -- []
After data Addition to ArrayList
strArray.Size : 4 -- [Hello, Mother, Father, Haha]
strArray.Size : 3 -- [Mother, Father, Haha]



4. Stack
-- Stack class extends the Vector class and it is its subclass.
-- It works on the principle of Last-In, First-Out.
-- In order to put an object on the top of the stack, we call the push() method.
-- To remove and return the top element in the stack, we call pop() method.
-- There are other methods like peek(), search() and empty() which are used to perform operations on the stack.

1. Creating a default stack
   This creates an empty stack.
   Stack<Data-Type> stack = new Stack<Data-Type>();

Example --
Stack<String> strStack = new Stack<>() ;
System.out.println("strArray.Size : "+ strStack.size()+" -- "+strStack) ;
strStack.push("Hello") ;
strStack.push("Mother") ;
strStack.push("Father") ;
strStack.push("Haha") ;
System.out.println("After data Addition to ArrayList");
System.out.println("strArray.Size : "+ strStack.size()+" -- "+strStack) ;
strStack.pop() ;
System.out.println("After data pop from strStack");
System.out.println("strArray.Size : "+ strStack.size()+" -- "+strStack) ;
System.out.println("peeking from strStack: "+strStack.peek());

output --
strArray.Size : 0 -- []
After data Addition to strStack
strArray.Size : 4 -- [Hello, Mother, Father, Haha]
After data pop from strStack
strArray.Size : 3 -- [Hello, Mother, Father]
peeking from strStack: Father


Explanation:
-- In the above program saw methods like pop(), push() and peek(). We are adding elements using pop() function,
   removing the top using the push() function, and getting the top-most element by the peek() function.
-- One thing to note is that Stack is thread-safe. It might be overhead in an environment where the thread-safety
   concept is not needed. So, ArrayDeque is preferred.


Queue Interface
-- The Queue Interface extends the Collection interface.
-- It uses the principle of First-In, First-Out (FIFO).
-- A Queue is an ordered list where there is a need to maintain the order of the elements.
-- It has classes like PriorityQueue and ArrayDeque.
-- The most famous implementation is that of PriorityQueue.



[LinkedList class, PriorityQueue class] -----> (implements) ----> Queue Interface
PriorityQueue

## The PriorityQueue class extends AbstractQueue and implements the Queue Interface.
-- As the name suggests, they follow the principle of priority of the elements.
-- We know that we follow First-In, First-Out for queues, but at times, the elements need to be processed in terms of
   their priority. This is where the PriorityQueue comes into play.
-- It does not allow null values to be stored inside it.
-- The add() method is used to add an element while the poll() method is used to remove the top-most element. While,
   peek() is used to display the top-most element.


Methods to initialise a PriorityQueue using constructors
1. Creating an empty PriorityQueue
   PriorityQueue<Data-Type> pq = new PriorityQueue<Data-Type>();
2. Creating a PriorityQueue with the specified size
   PriorityQueue<Data-Type> pq = new PriorityQueue<Data-Type>(int size);
3. Creating a PriorityQueue from Collection
   It will create a PriorityQueue with all the elements of Collection C.
4. Syntax --  PriorityQueue<Data-Type> pq = new PriorityQueue<Data-Type>(Collection<Data-Type> C);


Example ---
PriorityQueue<String> strPriorityQueue = new PriorityQueue<>() ;
System.out.println("strPriorityQueue.Size : "+ strPriorityQueue.size()+" -- "+strPriorityQueue) ;
strPriorityQueue.add("Hello") ;
strPriorityQueue.add("Mother") ;
strPriorityQueue.add("Father") ;
strPriorityQueue.add("Haha") ;
System.out.println("After data Addition to ArrayList");
System.out.println("strPriorityQueue.size : "+ strPriorityQueue.size()+" -- "+strPriorityQueue) ;
strPriorityQueue.poll() ;
System.out.println("After data pop from strPriorityQueue");
System.out.println("strArray.Size : "+ strPriorityQueue.size()+" -- "+strPriorityQueue) ;
System.out.println("peeking from strPriorityQueue: "+strPriorityQueue.peek());

output --
strPriorityQueue.Size : 0 -- []
After data Addition to ArrayList
strPriorityQueue.Size : 4 -- [Father, Haha, Hello, Mother]
After data pop from strPriorityQueue
strArray.Size : 3 -- [Haha, Mother, Hello]
peeking from strPriorityQueue: Haha


SET INTERFACE ---
-- The Set interface defines an unordered collection.
-- It extends the Collection Interface.
-- We cannot store duplicate values in this.
-- The Set Interface is implemented by popular classes like HashedSet class, LinkedHashSet class, and TreeSet class.

Set<Data-Type> hs = new HashSet<Data-Type>();
Set<Data-Type> lhs = new LinkedHashSet<Data-Type>();
Set<Data-Type> ts = new TreeSet<Data-Type>();

### HashSet
-- The HashSet class implements the Set Interface.
-- It uses a hash table for storage which uses a mechanism called Hashing.
-- In hashing, the informational content of a key determines a unique value, called its hash code.
-- The hash code is then used as an index, at which the data associated with the key is stored.
-- When we insert elements into the HashSet, it is not guaranteed that it gets stored in the same order.
-- We can store Null values in this.
-- HashSet is non-synchronized means multiple threads at a time can access the code. This means if one thread is
   working on HashSet, other threads can also get a hold of it. Multiple operations on HashSet can be performed at a time.



## Methods to create the constructors of HashSet
1. Creating an empty HashSet It is used to create an empty HashSet object in which the default initial capacity is 16.
   HashSet<Data-type> hs = new HashSet<Data-type>();
2. Creating a HashSet with a specified size It is used to create a HashSet with the given size.
   HashSet<Data-type> hs = new HashSet<Data-type>(int size);
3. Creating a HashSet with a specified size and fill ratio It is used to create a HashSet with a given size and fill ratio.
   HashSet<Data-type> hs = new HashSet<Data-type>(int size,float fillRatio);
4. Creating a HashSet from Collection It is used to create a HashSet which contains all the elements from the collection.
   HashSet<Data-type> hs = new HashSet<Data-type>(Collection C);


HashSet<String> strHashSet = new HashSet<>() ;
System.out.println("strHashSet.Size : "+ strHashSet.size()+" -- "+strHashSet) ;
strHashSet.add("Hello")  ;
strHashSet.add("Mother") ;
strHashSet.add("Father") ;
strHashSet.add("Haha")   ;
System.out.println("After data Addition to ArrayList");
System.out.println("strHashSet.size : "+ strHashSet.size()+" -- "+strHashSet) ;
strHashSet.remove("Father") ;
System.out.println("After data pop from strHashSet");
System.out.println("strHashSet.Size : "+ strHashSet.size()+" -- "+strHashSet) ;


SAME FOR LINKEDHASHSET --


### LinkedHashSet --
-- The LinkedHashSet class extends the HashSet class.
-- It maintains a linked list of entries in the set and hence maintains the order in which they were inserted.
-- LinkedHashSet is non-synchronized means multiple threads at a time can access the code. This means if one thread
   is working on LinkedHashSet, other threads can also get a hold of it. Multiple operations on LinkedHashSet can be
   performed at a time. For example, if addition is being performed by one thread, other operation can be performed by
   some other thread too.


### SortedSet Interface
-- The SortedSet Interface extends the Set Interface.
-- It is similar to the Set Interface but plays a vital role to arrange data in ascending or sorted manner.
-- The TreeSet class implements this interface.


### TreeSet --
-- The TreeSet class implements the Set Interface.
-- It uses a tree to store the elements.
-- TreeSet contains unique elements.
-- The access and retrieval time is very fast.
-- TreeSet is non-synchronized means multiple threads at a time can access the code. This means if one thread is
   working on TreeSet, other threads can also get a hold of it. Multiple operations on TreeSet can be performed at
   a time. For example, if addition is being performed by one thread, other operations can be performed by some other
   thread too.



### Map Interface
-- A map is an object that stores key and value pairs.
-- It contains unique keys as the same key cannot have multiple mappings.
-- Although a part of the Collections Framework, maps are not themselves collections because they do not implement the Collection Interface.

Syntax -- Map<Data-Type> hm = new HashMap<> ();

### HashMap --
-- The HashMap class extends AbstractMap and implements the Map interface.
-- It uses a hash table for storing key-value pairs.
-- If we want to access a value in a** hash map**, we must know its key.











































